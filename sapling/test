#!/usr/bin/env python2.7
# coding=utf-8

import contextlib
import os.path
import re
import shutil
import subprocess
import tempfile
import unittest

class TestCaseCleanupMixin(object):
    def enter_context(self, context_manager):
        exit = context_manager.__exit__
        value = context_manager.__enter__()
        self.addCleanup(lambda: exit(None, None, None))
        return value

class TestSLStragerLog(unittest.TestCase, TestCaseCleanupMixin):
    __counter = 0

    def setUp(self):
        super(TestSLStragerLog, self).setUp()
        self.repo_path = self.enter_context(empty_sl_repo())

    def test_log_of_empty_repo_is_empty(self):
        log = self.strager_log()
        self.assertEqual(log, '')

    def test_draft_commit_shows_short_hash_right_of_graph(self):
        commit_hash = self.commit('my commit')

        short_commit_hash = commit_hash[0:10]
        self.assert_strager_log_regexp(r'''
            ^ @ [ ]+ {short_commit_hash} [ ]+ .* $
        '''.format(short_commit_hash=re.escape(short_commit_hash)))

    def test_draft_commit_without_phabricator_revision_shows_dashes_between_hash_and_message(self):
        self.commit('my commit')
        self.assert_strager_log_regexp(r'''
            ^ @ [ ]+ [0-9a-f]+ [ ]+ ──────── [ ] my[ ]commit $
        ''')

    @unittest.skip("feature relies on internal FB code")
    def test_draft_commit_with_phabricator_revision_shows_revision_between_hash_and_message(self):
        self.commit(r'''my commit

Differential Revision: https://phabricator.intern.facebook.com/D1234567
''')
        self.assert_strager_log_regexp(r'''
            ^ @ [ ]+ [0-9a-f]+ [ ]+ D1234567 [ ] my[ ]commit $
        ''')

    def test_commit_obsoleted_by_rebase_shows_successor_commit_hashes_after_message(self):
        initial_commit_hash = self.commit('initial commit')
        self.commit('second commit')
        old_moved_commit_hash = self.commit('moved commit')
        self.commit('top commit')
        self.check_call(['sl', 'rebase', '--rev', old_moved_commit_hash, '--dest', initial_commit_hash])
        new_moved_commit_hash = self.commit_hash('successors({0}) & !{0}'.format(old_moved_commit_hash))

        old_moved_short_commit_hash = old_moved_commit_hash[0:10]
        new_moved_short_commit_hash = new_moved_commit_hash[0:10]
        self.assert_strager_log_regexp(r'''
            ^ .* \b{old_moved_short_commit_hash}\b .* moved[ ]commit[ ]\(successor:[ ]{new_moved_short_commit_hash}\) $
        '''.format(
            new_moved_short_commit_hash=re.escape(new_moved_short_commit_hash),
            old_moved_short_commit_hash=re.escape(old_moved_short_commit_hash),
        ))

    def test_log_of_linear_history_shows_graph(self):
        self.add_public_commit()
        self.commit('commit A')
        self.commit('commit B')
        self.commit('commit C')

        self.assert_strager_log_regexp(r'''
            ^ @[ ] .* $\n
            ^ o[ ] .* $\n
            ^ o[ ] .* $\n
            ^ o[ ] .* $\n
        ''')

    def test_log_of_forked_draft_history_shows_graph(self):
        self.add_public_commit()
        self.commit('commit A')
        self.commit('commit B')
        self.commit('commit C1')
        self.goto('.~1')
        self.commit('commit C2')

        self.assert_strager_log_regexp(r'''
            ^ @[ ] .* $\n
            ^ │[ ]o[ ] .* $\n
            ^ ├─╯ $\n
            ^ o[ ] .* $\n
            ^ o[ ] .* $\n
        ''')

    def test_commit_message_is_horizontally_aligned(self):
        self.add_public_commit()
        self.commit('commit A')
        self.commit('commit B')
        self.commit('commit C1')
        self.goto('.~1')
        self.commit('commit C2a')
        self.commit('commit C2b')
        self.goto('.~1')
        self.commit('commit C2c')
        commit_messages = ['commit A', 'commit B', 'commit C1', 'commit C2a', 'commit C2b', 'commit C2c']

        log = self.strager_log()

        def column_of_commit_message(message):
            regexp = re.compile(r'^(?P<before>.*){message}$'.format(message=re.escape(message)), re.MULTILINE)
            match = regexp.search(log)
            self.assertIsNotNone(match, '{message} should be in {log}'.format(log=repr(log), message=repr(message)))
            return len(match.group('before').decode('utf-8'))

        column_by_commit = {
            message: column_of_commit_message(message)
            for message in commit_messages
        }
        expected_column = column_by_commit['commit A']
        for message, column in column_by_commit.iteritems():
            self.assertEqual(column, expected_column, "{message}'s message should be at the same column as commit A\n{log}\n{column_by_commit!r}".format(message=message, log=log, column_by_commit=column_by_commit))

    def strager_log(self):
        return self.check_output(['sl', 'l'])

    def assert_strager_log_regexp(self, regexp_string):
        regexp = re.compile(regexp_string, re.MULTILINE | re.VERBOSE)
        log = self.strager_log()
        self.assertRegexpMatches(log, regexp)

    def add_public_commit(self):
        self.commit('public commit')
        self.check_call(['sl', 'phase', '--public', '.'])

    def commit(self, message):
        self.add_new_file()
        self.check_call(['sl', 'commit', '--message', message])
        return self.commit_hash('.')

    def goto(self, revision):
        self.check_call(['sl', 'goto', '--rev', revision])

    def add_new_file(self):
        self.add_file('file_{}'.format(self.__counter))
        self.__counter += 1

    def add_file(self, path):
        with open(os.path.join(self.repo_path, path), 'wb'):
            pass
        self.check_call(['sl', 'add', '--', path])

    def commit_hash(self, rev):
        stdout = self.check_output(['sl', 'log', '--template', '{node}', '--rev', rev])
        return stdout.rstrip('\n')

    def check_call(self, command):
        subprocess.check_call(command, cwd=self.repo_path)

    def check_output(self, command):
        return subprocess.check_output(command, cwd=self.repo_path)

@contextlib.contextmanager
def empty_sl_repo():
    with temporary_directory() as repo_dir_path:
        subprocess.check_call(['sl', 'init', '--git', 'repo'], cwd=repo_dir_path)
        yield os.path.join(repo_dir_path, 'repo')

@contextlib.contextmanager
def temporary_directory():
    path = tempfile.mkdtemp()
    try:
        yield path
    finally:
        shutil.rmtree(path)

if __name__ == '__main__':
    unittest.main()
